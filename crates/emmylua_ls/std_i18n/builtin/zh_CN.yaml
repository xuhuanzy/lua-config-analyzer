nil: |
  *nil* 类型只有一个值 **nil**，其主要特性是与任何其他值都不同；
  它通常表示缺少有用的值。

boolean: |
  *boolean* 类型有两个值：**false** 和 **true**。**nil** 和 **false**
  都会使条件为假；任何其他值都会使条件为真。

number: |
  **number** 类型在内部使用两种表示形式，或称为两种子类型，一种叫做
  *integer*，另一种叫做 *float*。Lua 对于何时使用哪种表示形式有明确的规则，
  但也会在需要时自动进行转换。因此，程序员可以选择忽略整数和浮点数之间的差异，
  也可以完全控制每个数字的表示形式。标准 Lua 使用 64 位整数和双精度（64 位）
  浮点数，但你也可以将 Lua 编译为使用 32 位整数和/或单精度（32 位）浮点数。
  对于小型机器和嵌入式系统来说，同时使用 32 位整数和 32 位浮点数的选项特别有吸引力。
  （参见 `luaconf.h` 文件中的宏 `LUA_32BITS`。）

userdata: |
  *userdata* 类型用于允许将任意 C 数据存储在 Lua 变量中。userdata 值
  表示一块原始内存。有两种 userdata：*full userdata*，是一个由 Lua
  管理内存块的对象；*light userdata*，它仅是一个 C 指针值。userdata 在
  Lua 中没有预定义的操作，除了赋值和相等性测试。通过使用 *metatables*，程序员
  可以为 full userdata 值定义操作。userdata 值不能在 Lua 中创建或修改，
  只能通过 C API 进行。这保证了宿主程序所拥有数据的完整性。

thread: |
  *thread* 类型表示独立的执行线程，用于实现协程。Lua 线程与操作系统
  线程无关。Lua 在所有系统上都支持协程，即使是那些原生不支持线程的系统。

table: |
  *table* 类型实现关联数组，即索引不仅可以是数字，还可以是除 **nil**
  和 NaN 之外的任何 Lua 值的数组。（*NaN* 是 IEEE 754 标准用于表示
  未定义或不可表示的数值结果的特殊浮点值，例如 `0/0`。）表可以是异构的；
  也就是说，它们可以包含所有类型的值（除了 **nil**）。值为 **nil** 的
  任何键都不被视为表的一部分。相反，任何不属于表的键其关联值都为 **nil**。

  表是 Lua 中唯一的数据结构；它们可以用来表示普通数组、列表、符号表、
  集合、记录、图、树等。为了表示记录，Lua 使用字段名作为索引。语言通过
  提供 `a.name` 作为 `a["name"]` 的语法糖来支持这种表示。

  与索引一样，表字段的值可以是任何类型。特别地，由于函数是一等公民，表
  字段可以包含函数。因此表也可以携带 *methods*。

  表的索引遵循语言中原始相等的定义。表达式 `a[i]` 和 `a[j]` 当且仅当
  `i` 和 `j` 原始相等（即不使用元方法的相等）时表示相同的表元素。特别地，
  具有整数值的浮点数等于其对应的整数。为避免歧义，任何用作键的具有整数值
  的浮点数都会转换为其对应的整数。例如，如果你写 `a[2.0] = true`，
  插入表中的实际键将是整数 `2`。（另一方面，2 和 "`2`" 是不同的 Lua 值，
  因此表示不同的表条目。）

std.Select: |
  Select 函数的内置类型

std.Unpack: |
  Unpack 函数的内置类型

std.RawGet: |
  Rawget 的内置类型

std.ConstTpl: |
  泛型模板的内置类型，用于匹配整数常量和 true/false

Parameters: |
  以元组形式获取函数的参数

ConstructorParameters: |
  以元组形式获取构造函数的参数

Partial: |
  使 T 中的所有属性变为可选
