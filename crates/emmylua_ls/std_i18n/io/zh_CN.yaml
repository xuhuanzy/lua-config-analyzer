iolib.close: |
  相当于 `file:close()`。如果没有指定文件，则关闭默认输出文件。

iolib.flush: |
  相当于 `io.output():flush()`。

iolib.input: |
  当使用文件名调用时，它打开命名的文件（以文本模式），并将该文件句柄
  设置为默认输入文件。当使用文件句柄调用时，它只是将此文件句柄设置为
  默认输入文件。当不带参数调用时，它返回当前的默认输入文件。

  如果发生错误，此函数会引发错误，而不是返回错误代码。

iolib.lines: |
  以读取模式打开给定的文件名，并返回一个像 `file:lines(...)` 一样
  在打开的文件上工作的迭代器函数。当迭代器函数检测到文件末尾时，
  它不返回任何值（以结束循环）并自动关闭文件。

  调用 `io.lines()`（不带文件名）相当于 `io.input():lines()`；
  也就是说，它遍历默认输入文件的行。在这种情况下，迭代器在循环结束时
  不会关闭文件。

  如果发生错误，此函数会引发错误，而不是返回错误代码。

iolib.open: |
  此函数以字符串 `mode` 指定的模式打开文件。如果成功，它返回一个新的
  文件句柄。`mode` 字符串可以是以下任意一种：

  **"r"**: 读取模式（默认）；
  **"w"**: 写入模式；
  **"a"**: 追加模式；
  **"r+"**: 更新模式，保留所有先前的数据；
  **"w+"**: 更新模式，擦除所有先前的数据；
  **"a+"**: 追加更新模式，保留先前的数据，只允许在文件末尾写入。

  `mode` 字符串末尾也可以有一个 '`b`'，在某些系统中需要它以二进制模式打开文件。

iolib.output: |
  类似于 `io.input`，但操作的是默认输出文件。

iolib.popen: |
  此函数依赖于系统，并非在所有平台上都可用。

  在单独的进程中启动程序 `prog`，并返回一个文件句柄，你可以使用它
  从此程序读取数据（如果 `mode` 是 "`r`"，默认值）或向此程序写入数据
  （如果 `mode` 是 "`w`"）。

std.readmode.item.n: |
  读取一个数字，根据 Lua 的转换语法返回浮点数或整数。

std.readmode.item.a: |
  从当前位置开始读取整个文件。

std.readmode.item.l: |
  读取一行并忽略行尾标记。

std.readmode.item.L: |
  读取一行并保留行尾标记。

std.readmode.item.*n: |
  读取一个数字，根据 Lua 的转换语法返回浮点数或整数。

std.readmode.item.*a: |
  从当前位置开始读取整个文件。

std.readmode.item.*l: |
  读取一行并忽略行尾标记。

std.readmode.item.*L: |
  读取一行并保留行尾标记。

iolib.read: |
  相当于 `io.input():read(...)`。

iolib.tmpfile: |
  如果成功，返回一个临时文件的句柄。此文件以更新模式打开，
  并在程序结束时自动删除。

iolib.type: |
  检查 `obj` 是否为有效的文件句柄。如果 `obj` 是打开的文件句柄，
  返回字符串 "`file`"；如果 `obj` 是已关闭的文件句柄，
  返回 "`closed file`"；如果 `obj` 不是文件句柄，返回 **nil**。

iolib.write: |
  相当于 `io.output():write(...)`。

file: |
  文件对象

file.close@>5.2: |
  关闭 `file`。请注意，当文件句柄被垃圾收集时，文件会自动关闭，
  但这需要的时间是不可预测的。

  当关闭由 `io.popen` 创建的文件句柄时，`file:close` 返回
  与 `os.execute` 相同的返回值。

# Closes `file`. Note that files are automatically closed when their
#  handles are garbage collected, but that takes an unpredictable amount of
#  time to happen.
file.close@5.1,JIT: ""

file.flush: |
  将任何写入的数据保存到 `file`。

file.lines: |
  返回一个迭代器函数，每次调用时，都会根据给定的格式读取文件。
  如果没有给出格式，默认使用 "l"。例如，构造
  `for c in file:lines(1) do *body* end`
  将从当前位置开始遍历文件的所有字符。与 `io.lines` 不同，
  此函数在循环结束时不会关闭文件。

  如果发生错误，此函数会引发错误，而不是返回错误代码。

file.read: |
  根据给定的格式读取文件 `file`，格式指定了要读取的内容。对于每种格式，
  该函数返回一个包含读取字符的字符串或数字，如果无法使用指定格式
  读取数据，则返回 **nil**。（在后一种情况下，函数不会读取后续格式。）
  当不带参数调用时，它使用默认格式读取下一行（见下文）。
  -
  可用的格式有：
  **"n"**: 读取一个数字，并根据 Lua 的词法约定将其作为浮点数或整数返回。
  （数字可以有前导空格和符号。）此格式总是读取作为数字有效前缀的最长
  输入序列；如果该前缀不构成有效数字（例如空字符串、"`0x`" 或 "`3.4e-`"），
  它将被丢弃，并且格式返回 **nil**；
  **"a"**: 从当前位置开始读取整个文件。在文件末尾，它返回空字符串；
  **"l"**: 读取下一行，跳过行尾，在文件末尾返回 **nil**。这是默认格式。
  **"L"**: 读取下一行，保留行尾字符（如果存在），在文件末尾返回 **nil**；
  *number*: 读取最多包含此字节数的字符串，在文件末尾返回 **nil**。
  如果 `number` 为零，它不读取任何内容并返回空字符串，或在文件末尾返回 **nil**。

file.seek: |
  设置并获取文件位置，位置从文件开头测量，由 `offset` 加上字符串 `whence`
  指定的基准决定，如下所示：
  **"set"**: 基准是位置 0（文件开头）；
  **"cur"**: 基准是当前位置；
  **"end"**: 基准是文件末尾；

  如果成功，`seek` 返回最终文件位置，以从文件开头算起的字节数测量。
  如果 `seek` 失败，它返回 **nil** 加上描述错误的字符串。

  `whence` 的默认值为 "`cur`"，`offset` 的默认值为 0。因此，
  调用 `file:seek()` 返回当前文件位置而不改变它；
  调用 `file:seek("set")` 将位置设置为文件开头（并返回 0）；
  调用 `file:seek("end")` 将位置设置为文件末尾，并返回其大小。

file.setvbuf: |
  设置输出文件的缓冲模式。有三种可用模式：
  **"no"**: 无缓冲；任何输出操作的结果立即出现。
  **"full"**: 全缓冲；仅当缓冲区已满（或显式 `flush` 文件（见 `io.flush`））
  时才执行输出操作。
  **"line"**: 行缓冲；输出被缓冲直到输出换行符或从某些特殊文件
  （如终端设备）有任何输入。

  对于后两种情况，`size` 指定缓冲区的大小（以字节为单位）。默认是合适的大小。

file.write: |
  将其每个参数的值写入 `file`。参数必须是字符串或数字。

  如果成功，此函数返回 `file`。否则它返回 **nil** 加上描述错误的字符串。

iolib.stderr: |
  标准错误输出。

iolib.stdin: |
  标准输入。

iolib.stdout: |
  标准输出。
